// Package schema provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package schema

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

// Defines values for ExperimentField.
const (
	ExperimentFieldEndTime ExperimentField = "end_time"

	ExperimentFieldId ExperimentField = "id"

	ExperimentFieldName ExperimentField = "name"

	ExperimentFieldStartTime ExperimentField = "start_time"

	ExperimentFieldStatusFriendly ExperimentField = "status_friendly"

	ExperimentFieldTier ExperimentField = "tier"

	ExperimentFieldTreatments ExperimentField = "treatments"

	ExperimentFieldType ExperimentField = "type"

	ExperimentFieldUpdatedAt ExperimentField = "updated_at"
)

// Defines values for ExperimentStatus.
const (
	ExperimentStatusActive ExperimentStatus = "active"

	ExperimentStatusInactive ExperimentStatus = "inactive"
)

// Defines values for ExperimentStatusFriendly.
const (
	ExperimentStatusFriendlyCompleted ExperimentStatusFriendly = "completed"

	ExperimentStatusFriendlyDeactivated ExperimentStatusFriendly = "deactivated"

	ExperimentStatusFriendlyRunning ExperimentStatusFriendly = "running"

	ExperimentStatusFriendlyScheduled ExperimentStatusFriendly = "scheduled"
)

// Defines values for ExperimentTier.
const (
	ExperimentTierDefault ExperimentTier = "default"

	ExperimentTierOverride ExperimentTier = "override"
)

// Defines values for ExperimentType.
const (
	ExperimentTypeAB ExperimentType = "A/B"

	ExperimentTypeSwitchback ExperimentType = "Switchback"
)

// Defines values for SegmentField.
const (
	SegmentFieldId SegmentField = "id"

	SegmentFieldName SegmentField = "name"
)

// Defines values for SegmenterScope.
const (
	SegmenterScopeGlobal SegmenterScope = "global"

	SegmenterScopeProject SegmenterScope = "project"
)

// Defines values for SegmenterStatus.
const (
	SegmenterStatusActive SegmenterStatus = "active"

	SegmenterStatusInactive SegmenterStatus = "inactive"
)

// Defines values for SegmenterType.
const (
	SegmenterTypeBool SegmenterType = "bool"

	SegmenterTypeInteger SegmenterType = "integer"

	SegmenterTypeReal SegmenterType = "real"

	SegmenterTypeString SegmenterType = "string"
)

// Defines values for TreatmentField.
const (
	TreatmentFieldId TreatmentField = "id"

	TreatmentFieldName TreatmentField = "name"
)

// Constraint defines model for Constraint.
type Constraint struct {
	AllowedValues []SegmenterValues `json:"allowed_values"`
	Options       *SegmenterOptions `json:"options,omitempty"`
	PreRequisites []PreRequisite    `json:"pre_requisites"`
}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Error   string `json:"error"`
	Message string `json:"message"`
}

// Experiment defines model for Experiment.
type Experiment struct {
	CreatedAt   *time.Time         `json:"created_at,omitempty"`
	Description *string            `json:"description"`
	EndTime     *time.Time         `json:"end_time,omitempty"`
	Id          *int64             `json:"id,omitempty"`
	Interval    *int32             `json:"interval"`
	Name        *string            `json:"name,omitempty"`
	ProjectId   *int64             `json:"project_id,omitempty"`
	Segment     *ExperimentSegment `json:"segment,omitempty"`
	StartTime   *time.Time         `json:"start_time,omitempty"`
	Status      *ExperimentStatus  `json:"status,omitempty"`

	// The user-friendly classification of experiment statuses. The categories are
	// self-explanatory. Note that the current time plays a role in the definition
	// of some of these statuses.
	StatusFriendly *ExperimentStatusFriendly `json:"status_friendly,omitempty"`
	Tier           *ExperimentTier           `json:"tier,omitempty"`
	Treatments     *[]ExperimentTreatment    `json:"treatments,omitempty"`
	Type           *ExperimentType           `json:"type,omitempty"`
	UpdatedAt      *time.Time                `json:"updated_at,omitempty"`
	UpdatedBy      *string                   `json:"updated_by,omitempty"`
	Version        *int64                    `json:"version,omitempty"`
}

// ExperimentField defines model for ExperimentField.
type ExperimentField string

// ExperimentHistory defines model for ExperimentHistory.
type ExperimentHistory struct {
	CreatedAt    time.Time             `json:"created_at"`
	Description  *string               `json:"description"`
	EndTime      time.Time             `json:"end_time"`
	ExperimentId int64                 `json:"experiment_id"`
	Id           int64                 `json:"id"`
	Interval     *int32                `json:"interval"`
	Name         string                `json:"name"`
	Segment      ExperimentSegment     `json:"segment"`
	StartTime    time.Time             `json:"start_time"`
	Status       ExperimentStatus      `json:"status"`
	Tier         ExperimentTier        `json:"tier"`
	Treatments   []ExperimentTreatment `json:"treatments"`
	Type         ExperimentType        `json:"type"`
	UpdatedAt    time.Time             `json:"updated_at"`
	UpdatedBy    string                `json:"updated_by"`
	Version      int64                 `json:"version"`
}

// ExperimentSegment defines model for ExperimentSegment.
type ExperimentSegment map[string]interface{}

// ExperimentStatus defines model for ExperimentStatus.
type ExperimentStatus string

// The user-friendly classification of experiment statuses. The categories are
// self-explanatory. Note that the current time plays a role in the definition
// of some of these statuses.
type ExperimentStatusFriendly string

// ExperimentTier defines model for ExperimentTier.
type ExperimentTier string

// ExperimentTreatment defines model for ExperimentTreatment.
type ExperimentTreatment struct {

	// Configuration associated with the given treatment
	Configuration map[string]interface{} `json:"configuration"`

	// Name of the treatment
	Name string `json:"name"`

	// When the experiment is matched, the % traffic to be directed to the treatment.
	// Optional for Switchback Experiments.
	Traffic *int32 `json:"traffic,omitempty"`
}

// ExperimentType defines model for ExperimentType.
type ExperimentType string

// NewRelicConfig defines model for NewRelicConfig.
type NewRelicConfig struct {

	// App name of the New Relic app
	AppName *string `json:"app_name,omitempty"`

	// Boolean indicating if New Relic is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// Paging defines model for Paging.
type Paging struct {

	// Number of the current page
	Page int32 `json:"page"`

	// Total number of pages
	Pages int32 `json:"pages"`

	// Total number of results matching the query criteria
	Total int32 `json:"total"`
}

// PreRequisite defines model for PreRequisite.
type PreRequisite struct {
	SegmenterName   string            `json:"segmenter_name"`
	SegmenterValues []SegmenterValues `json:"segmenter_values"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt        time.Time `json:"created_at"`
	Id               int64     `json:"id"`
	RandomizationKey string    `json:"randomization_key"`
	Segmenters       []string  `json:"segmenters"`
	UpdatedAt        time.Time `json:"updated_at"`
	Username         string    `json:"username"`
}

// ProjectSegmenters defines model for ProjectSegmenters.
type ProjectSegmenters struct {

	// List of segmenters name within Project, in priority order.
	Names []string `json:"names"`

	// Mapping of segmenter to the configured experiment variables
	Variables ProjectSegmenters_Variables `json:"variables"`
}

// Mapping of segmenter to the configured experiment variables
type ProjectSegmenters_Variables struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// ProjectSettings defines model for ProjectSettings.
type ProjectSettings struct {
	CreatedAt            time.Time         `json:"created_at"`
	EnableS2idClustering bool              `json:"enable_s2id_clustering"`
	Passkey              string            `json:"passkey"`
	ProjectId            int64             `json:"project_id"`
	RandomizationKey     string            `json:"randomization_key"`
	Segmenters           ProjectSegmenters `json:"segmenters"`

	// Object containing information to define a valid treatment schema
	TreatmentSchema *TreatmentSchema `json:"treatment_schema,omitempty"`
	UpdatedAt       time.Time        `json:"updated_at"`
	Username        string           `json:"username"`
	ValidationUrl   *string          `json:"validation_url,omitempty"`
}

// PubSub defines model for PubSub.
type PubSub struct {

	// Project name of the PubSub subscription
	Project *string `json:"project,omitempty"`

	// Topic name of the PubSub subscription
	TopicName *string `json:"topic_name,omitempty"`
}

// A rule that forms part of a definition of a valid treatment schema
type Rule struct {
	Name string `json:"name"`

	// A Go template expression that must return a boolean value
	Predicate string `json:"predicate"`
}

// List of rules that define a valid treatment schema
type Rules []Rule

// S2Ids defines model for S2Ids.
type S2Ids struct {

	// Max S2 cell level
	MaxS2CellLevel *int `json:"max_s2_cell_level,omitempty"`

	// Min S2 cell level
	MinS2CellLevel *int `json:"min_s2_cell_level,omitempty"`
}

// Segment defines model for Segment.
type Segment struct {
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Id        *int64             `json:"id,omitempty"`
	Name      *string            `json:"name,omitempty"`
	ProjectId *int64             `json:"project_id,omitempty"`
	Segment   *ExperimentSegment `json:"segment,omitempty"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`
	UpdatedBy *string            `json:"updated_by,omitempty"`
}

// SegmentField defines model for SegmentField.
type SegmentField string

// SegmentHistory defines model for SegmentHistory.
type SegmentHistory struct {
	CreatedAt time.Time         `json:"created_at"`
	Id        int64             `json:"id"`
	Name      string            `json:"name"`
	Segment   ExperimentSegment `json:"segment"`
	SegmentId int64             `json:"segment_id"`
	UpdatedAt time.Time         `json:"updated_at"`
	UpdatedBy string            `json:"updated_by"`
	Version   int64             `json:"version"`
}

// Segmenter defines model for Segmenter.
type Segmenter struct {
	Constraints []Constraint     `json:"constraints"`
	CreatedAt   *time.Time       `json:"created_at,omitempty"`
	Description *string          `json:"description,omitempty"`
	MultiValued bool             `json:"multi_valued"`
	Name        string           `json:"name"`
	Options     SegmenterOptions `json:"options"`
	Required    bool             `json:"required"`
	Scope       *SegmenterScope  `json:"scope,omitempty"`
	Status      *SegmenterStatus `json:"status,omitempty"`

	// List of varying combination of variables in which this segmenter is can be derived from
	TreatmentRequestFields [][]string    `json:"treatment_request_fields"`
	Type                   SegmenterType `json:"type"`
	UpdatedAt              *time.Time    `json:"updated_at,omitempty"`
}

// SegmenterConfig defines model for SegmenterConfig.
type SegmenterConfig struct {
	S2Ids *S2Ids `json:"s2_ids,omitempty"`
}

// SegmenterOptions defines model for SegmenterOptions.
type SegmenterOptions struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SegmenterScope defines model for SegmenterScope.
type SegmenterScope string

// SegmenterStatus defines model for SegmenterStatus.
type SegmenterStatus string

// SegmenterType defines model for SegmenterType.
type SegmenterType string

// SegmenterValues defines model for SegmenterValues.
type SegmenterValues interface{}

// SelectedTreatment defines model for SelectedTreatment.
type SelectedTreatment struct {
	ExperimentId   int64                     `json:"experiment_id"`
	ExperimentName string                    `json:"experiment_name"`
	Metadata       SelectedTreatmentMetadata `json:"metadata"`
	Treatment      SelectedTreatmentData     `json:"treatment"`
}

// SelectedTreatmentData defines model for SelectedTreatmentData.
type SelectedTreatmentData struct {

	// Custom configuration associated with the given treatment
	Configuration map[string]interface{} `json:"configuration"`
	Id            *int64                 `json:"id,omitempty"`

	// Name of the treatment
	Name string `json:"name"`

	// When the experiment is matched, the % traffic to be directed to the treatment.
	// Optional for Switchback Experiments.
	Traffic *int32 `json:"traffic,omitempty"`
}

// SelectedTreatmentMetadata defines model for SelectedTreatmentMetadata.
type SelectedTreatmentMetadata struct {
	ExperimentType    ExperimentType `json:"experiment_type"`
	ExperimentVersion int64          `json:"experiment_version"`

	// The window id since the beginning of the current version of the Switchback experiment.
	// This field will only be set for Switchback experiments and the window id starts at 0.
	SwitchbackWindowId *int64 `json:"switchback_window_id,omitempty"`
}

// SentryConfig defines model for SentryConfig.
type SentryConfig struct {

	// Boolean indicating if Sentry is enabled
	Enabled *bool                   `json:"enabled,omitempty"`
	Labels  *map[string]interface{} `json:"labels,omitempty"`
}

// Treatment defines model for Treatment.
type Treatment struct {
	Configuration *map[string]interface{} `json:"configuration,omitempty"`
	CreatedAt     *time.Time              `json:"created_at,omitempty"`
	Id            *int64                  `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	ProjectId     *int64                  `json:"project_id,omitempty"`
	UpdatedAt     *time.Time              `json:"updated_at,omitempty"`
	UpdatedBy     *string                 `json:"updated_by,omitempty"`
}

// TreatmentField defines model for TreatmentField.
type TreatmentField string

// TreatmentHistory defines model for TreatmentHistory.
type TreatmentHistory struct {
	Configuration map[string]interface{} `json:"configuration"`
	CreatedAt     time.Time              `json:"created_at"`
	Id            int64                  `json:"id"`
	Name          string                 `json:"name"`
	TreatmentId   int64                  `json:"treatment_id"`
	UpdatedAt     time.Time              `json:"updated_at"`
	UpdatedBy     string                 `json:"updated_by"`
	Version       int64                  `json:"version"`
}

// Object containing information to define a valid treatment schema
type TreatmentSchema struct {

	// List of rules that define a valid treatment schema
	Rules Rules `json:"rules"`
}

// TreatmentServicePluginConfig defines model for TreatmentServicePluginConfig.
type TreatmentServicePluginConfig struct {
	NewRelicConfig  *NewRelicConfig  `json:"new_relic_config,omitempty"`
	PubSub          *PubSub          `json:"pub_sub,omitempty"`
	SegmenterConfig *SegmenterConfig `json:"segmenter_config,omitempty"`
	SentryConfig    *SentryConfig    `json:"sentry_config,omitempty"`
}

// Getter for additional properties for ProjectSegmenters_Variables. Returns the specified
// element and whether it was found
func (a ProjectSegmenters_Variables) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProjectSegmenters_Variables
func (a *ProjectSegmenters_Variables) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProjectSegmenters_Variables to handle AdditionalProperties
func (a *ProjectSegmenters_Variables) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProjectSegmenters_Variables to handle AdditionalProperties
func (a ProjectSegmenters_Variables) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SegmenterOptions. Returns the specified
// element and whether it was found
func (a SegmenterOptions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SegmenterOptions
func (a *SegmenterOptions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SegmenterOptions to handle AdditionalProperties
func (a *SegmenterOptions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SegmenterOptions to handle AdditionalProperties
func (a SegmenterOptions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"l5f/BwAA//9W3c04+S4AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
