// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/http"
	"time"

	externalRef0 "github.com/caraml-dev/xp/common/api/schema"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// BadRequest defines model for BadRequest.
type BadRequest = externalRef0.Error

// CreateExperimentSuccess defines model for CreateExperimentSuccess.
type CreateExperimentSuccess struct {
	Data externalRef0.Experiment `json:"data"`
}

// CreateProjectSettingsSuccess defines model for CreateProjectSettingsSuccess.
type CreateProjectSettingsSuccess struct {
	Data externalRef0.ProjectSettings `json:"data"`
}

// CreateSegmenterSuccess defines model for CreateSegmenterSuccess.
type CreateSegmenterSuccess struct {
	Data externalRef0.Segmenter `json:"data"`
}

// DeleteSegmenterSuccess defines model for DeleteSegmenterSuccess.
type DeleteSegmenterSuccess struct {
	Name *string `json:"name,omitempty"`
}

// GetExperimentHistorySuccess defines model for GetExperimentHistorySuccess.
type GetExperimentHistorySuccess struct {
	Data externalRef0.ExperimentHistory `json:"data"`
}

// GetExperimentSuccess defines model for GetExperimentSuccess.
type GetExperimentSuccess struct {
	Data externalRef0.Experiment `json:"data"`
}

// GetProjectExperimentVariablesSuccess defines model for GetProjectExperimentVariablesSuccess.
type GetProjectExperimentVariablesSuccess struct {
	Data []string `json:"data"`
}

// GetProjectSettingsSuccess defines model for GetProjectSettingsSuccess.
type GetProjectSettingsSuccess struct {
	Data externalRef0.ProjectSettings `json:"data"`
}

// GetSegmenterSuccess defines model for GetSegmenterSuccess.
type GetSegmenterSuccess struct {
	Data externalRef0.Segmenter `json:"data"`
}

// InternalServerError defines model for InternalServerError.
type InternalServerError = externalRef0.Error

// ListExperimentHistorySuccess defines model for ListExperimentHistorySuccess.
type ListExperimentHistorySuccess struct {
	Data   []externalRef0.ExperimentHistory `json:"data"`
	Paging *externalRef0.Paging             `json:"paging,omitempty"`
}

// ListExperimentsSuccess defines model for ListExperimentsSuccess.
type ListExperimentsSuccess struct {
	Data   []externalRef0.Experiment `json:"data"`
	Paging *externalRef0.Paging      `json:"paging,omitempty"`
}

// ListProjectsSuccess defines model for ListProjectsSuccess.
type ListProjectsSuccess struct {
	Data []externalRef0.Project `json:"data"`
}

// ListSegmentersSuccess defines model for ListSegmentersSuccess.
type ListSegmentersSuccess struct {
	Data []externalRef0.Segmenter `json:"data"`
}

// NotFound defines model for NotFound.
type NotFound = externalRef0.Error

// UpdateExperimentSuccess defines model for UpdateExperimentSuccess.
type UpdateExperimentSuccess struct {
	Data externalRef0.Experiment `json:"data"`
}

// UpdateProjectSettingsSuccess defines model for UpdateProjectSettingsSuccess.
type UpdateProjectSettingsSuccess struct {
	Data externalRef0.ProjectSettings `json:"data"`
}

// UpdateSegmenterSuccess defines model for UpdateSegmenterSuccess.
type UpdateSegmenterSuccess struct {
	Data externalRef0.Segmenter `json:"data"`
}

// CreateExperimentRequestBody defines model for CreateExperimentRequestBody.
type CreateExperimentRequestBody struct {
	Description *string                            `json:"description"`
	EndTime     time.Time                          `json:"end_time"`
	Interval    *int32                             `json:"interval"`
	Name        string                             `json:"name"`
	Segment     externalRef0.ExperimentSegment     `json:"segment"`
	StartTime   time.Time                          `json:"start_time"`
	Status      externalRef0.ExperimentStatus      `json:"status"`
	Tier        *externalRef0.ExperimentTier       `json:"tier,omitempty"`
	Treatments  []externalRef0.ExperimentTreatment `json:"treatments"`
	Type        externalRef0.ExperimentType        `json:"type"`
	UpdatedBy   *string                            `json:"updated_by,omitempty"`
}

// CreateProjectSettingsRequestBody defines model for CreateProjectSettingsRequestBody.
type CreateProjectSettingsRequestBody struct {
	EnableS2idClustering *bool                          `json:"enable_s2id_clustering,omitempty"`
	RandomizationKey     string                         `json:"randomization_key"`
	Segmenters           externalRef0.ProjectSegmenters `json:"segmenters"`

	// TreatmentSchema Object containing information to define a valid treatment schema
	TreatmentSchema *externalRef0.TreatmentSchema `json:"treatment_schema,omitempty"`
	ValidationUrl   *string                       `json:"validation_url,omitempty"`
}

// CreateSegmenterRequestBody defines model for CreateSegmenterRequestBody.
type CreateSegmenterRequestBody struct {
	Constraints *[]externalRef0.Constraint     `json:"constraints,omitempty"`
	Description *string                        `json:"description,omitempty"`
	MultiValued bool                           `json:"multi_valued"`
	Name        string                         `json:"name"`
	Options     *externalRef0.SegmenterOptions `json:"options,omitempty"`
	Required    bool                           `json:"required"`
	Type        externalRef0.SegmenterType     `json:"type"`
}

// UpdateExperimentRequestBody defines model for UpdateExperimentRequestBody.
type UpdateExperimentRequestBody struct {
	Description *string                            `json:"description"`
	EndTime     time.Time                          `json:"end_time"`
	Interval    *int32                             `json:"interval"`
	Segment     externalRef0.ExperimentSegment     `json:"segment"`
	StartTime   time.Time                          `json:"start_time"`
	Status      externalRef0.ExperimentStatus      `json:"status"`
	Tier        *externalRef0.ExperimentTier       `json:"tier,omitempty"`
	Treatments  []externalRef0.ExperimentTreatment `json:"treatments"`
	Type        externalRef0.ExperimentType        `json:"type"`
	UpdatedBy   *string                            `json:"updated_by,omitempty"`
}

// UpdateProjectSettingsRequestBody defines model for UpdateProjectSettingsRequestBody.
type UpdateProjectSettingsRequestBody struct {
	EnableS2idClustering *bool                          `json:"enable_s2id_clustering,omitempty"`
	RandomizationKey     string                         `json:"randomization_key"`
	Segmenters           externalRef0.ProjectSegmenters `json:"segmenters"`

	// TreatmentSchema Object containing information to define a valid treatment schema
	TreatmentSchema *externalRef0.TreatmentSchema `json:"treatment_schema,omitempty"`
	ValidationUrl   *string                       `json:"validation_url,omitempty"`
}

// UpdateSegmenterRequestBody defines model for UpdateSegmenterRequestBody.
type UpdateSegmenterRequestBody struct {
	Constraints *[]externalRef0.Constraint     `json:"constraints,omitempty"`
	Description *string                        `json:"description,omitempty"`
	MultiValued bool                           `json:"multi_valued"`
	Options     *externalRef0.SegmenterOptions `json:"options,omitempty"`
	Required    bool                           `json:"required"`
}

// ListExperimentsParams defines parameters for ListExperiments.
type ListExperimentsParams struct {
	Status *externalRef0.ExperimentStatus `form:"status,omitempty" json:"status,omitempty"`

	// StatusFriendly status_friendly is a combination of the status field, in conjunction with the duration,
	// that produces a user-friendly classification of the experiment statuses. When this parameter
	// is supplied, the status, start_time and end_time filters can also be set. However, the final
	// result would be an intersection of the application of each of these filters.
	StatusFriendly *[]externalRef0.ExperimentStatusFriendly `form:"status_friendly,omitempty" json:"status_friendly,omitempty"`

	// EndTime Used together with the start_time, to filter experiments that are at least partially running in the input range.
	EndTime   *time.Time                   `form:"end_time,omitempty" json:"end_time,omitempty"`
	Tier      *externalRef0.ExperimentTier `form:"tier,omitempty" json:"tier,omitempty"`
	Type      *externalRef0.ExperimentType `form:"type,omitempty" json:"type,omitempty"`
	Name      *string                      `form:"name,omitempty" json:"name,omitempty"`
	UpdatedBy *string                      `form:"updated_by,omitempty" json:"updated_by,omitempty"`

	// Search Search experiment name and description for a partial match of the search text
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Page Result page number. It defaults to 1.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items on each page. It defaults to 10.
	PageSize *int32 `form:"page_size,omitempty" json:"page_size,omitempty"`

	// StartTime Used together with the end_time, to filter experiments that are at least partially running in the input range.
	StartTime *time.Time              `form:"start_time,omitempty" json:"start_time,omitempty"`
	Segment   *map[string]interface{} `form:"segment,omitempty" json:"segment,omitempty"`

	// IncludeWeakMatch controls whether or not weak segmenter matches (experiments where the segmenter is optional) should be returned
	IncludeWeakMatch *bool `form:"include_weak_match,omitempty" json:"include_weak_match,omitempty"`

	// Fields A selector to restrict the list of returned objects by their fields. If unset, all the fields will be returned.
	// Paginated responses will be returned if both or either of `page` and `page_size` parameters are provided.
	Fields *[]externalRef0.ExperimentField `form:"fields,omitempty" json:"fields,omitempty"`
}

// CreateExperimentJSONBody defines parameters for CreateExperiment.
type CreateExperimentJSONBody struct {
	Description *string                            `json:"description"`
	EndTime     time.Time                          `json:"end_time"`
	Interval    *int32                             `json:"interval"`
	Name        string                             `json:"name"`
	Segment     externalRef0.ExperimentSegment     `json:"segment"`
	StartTime   time.Time                          `json:"start_time"`
	Status      externalRef0.ExperimentStatus      `json:"status"`
	Tier        *externalRef0.ExperimentTier       `json:"tier,omitempty"`
	Treatments  []externalRef0.ExperimentTreatment `json:"treatments"`
	Type        externalRef0.ExperimentType        `json:"type"`
	UpdatedBy   *string                            `json:"updated_by,omitempty"`
}

// UpdateExperimentJSONBody defines parameters for UpdateExperiment.
type UpdateExperimentJSONBody struct {
	Description *string                            `json:"description"`
	EndTime     time.Time                          `json:"end_time"`
	Interval    *int32                             `json:"interval"`
	Segment     externalRef0.ExperimentSegment     `json:"segment"`
	StartTime   time.Time                          `json:"start_time"`
	Status      externalRef0.ExperimentStatus      `json:"status"`
	Tier        *externalRef0.ExperimentTier       `json:"tier,omitempty"`
	Treatments  []externalRef0.ExperimentTreatment `json:"treatments"`
	Type        externalRef0.ExperimentType        `json:"type"`
	UpdatedBy   *string                            `json:"updated_by,omitempty"`
}

// ListExperimentHistoryParams defines parameters for ListExperimentHistory.
type ListExperimentHistoryParams struct {
	// Page Result page number. It defaults to 1.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items on each page. It defaults to 10.
	PageSize *int32 `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// ListSegmentersParams defines parameters for ListSegmenters.
type ListSegmentersParams struct {
	Scope  *externalRef0.SegmenterScope  `form:"scope,omitempty" json:"scope,omitempty"`
	Status *externalRef0.SegmenterStatus `form:"status,omitempty" json:"status,omitempty"`

	// Search Search treatment name for a partial match of the search text
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// CreateSegmenterJSONBody defines parameters for CreateSegmenter.
type CreateSegmenterJSONBody struct {
	Constraints *[]externalRef0.Constraint     `json:"constraints,omitempty"`
	Description *string                        `json:"description,omitempty"`
	MultiValued bool                           `json:"multi_valued"`
	Name        string                         `json:"name"`
	Options     *externalRef0.SegmenterOptions `json:"options,omitempty"`
	Required    bool                           `json:"required"`
	Type        externalRef0.SegmenterType     `json:"type"`
}

// UpdateSegmenterJSONBody defines parameters for UpdateSegmenter.
type UpdateSegmenterJSONBody struct {
	Constraints *[]externalRef0.Constraint     `json:"constraints,omitempty"`
	Description *string                        `json:"description,omitempty"`
	MultiValued bool                           `json:"multi_valued"`
	Options     *externalRef0.SegmenterOptions `json:"options,omitempty"`
	Required    bool                           `json:"required"`
}

// CreateProjectSettingsJSONBody defines parameters for CreateProjectSettings.
type CreateProjectSettingsJSONBody struct {
	EnableS2idClustering *bool                          `json:"enable_s2id_clustering,omitempty"`
	RandomizationKey     string                         `json:"randomization_key"`
	Segmenters           externalRef0.ProjectSegmenters `json:"segmenters"`

	// TreatmentSchema Object containing information to define a valid treatment schema
	TreatmentSchema *externalRef0.TreatmentSchema `json:"treatment_schema,omitempty"`
	ValidationUrl   *string                       `json:"validation_url,omitempty"`
}

// UpdateProjectSettingsJSONBody defines parameters for UpdateProjectSettings.
type UpdateProjectSettingsJSONBody struct {
	EnableS2idClustering *bool                          `json:"enable_s2id_clustering,omitempty"`
	RandomizationKey     string                         `json:"randomization_key"`
	Segmenters           externalRef0.ProjectSegmenters `json:"segmenters"`

	// TreatmentSchema Object containing information to define a valid treatment schema
	TreatmentSchema *externalRef0.TreatmentSchema `json:"treatment_schema,omitempty"`
	ValidationUrl   *string                       `json:"validation_url,omitempty"`
}

// CreateExperimentJSONRequestBody defines body for CreateExperiment for application/json ContentType.
type CreateExperimentJSONRequestBody CreateExperimentJSONBody

// UpdateExperimentJSONRequestBody defines body for UpdateExperiment for application/json ContentType.
type UpdateExperimentJSONRequestBody UpdateExperimentJSONBody

// CreateSegmenterJSONRequestBody defines body for CreateSegmenter for application/json ContentType.
type CreateSegmenterJSONRequestBody CreateSegmenterJSONBody

// UpdateSegmenterJSONRequestBody defines body for UpdateSegmenter for application/json ContentType.
type UpdateSegmenterJSONRequestBody UpdateSegmenterJSONBody

// CreateProjectSettingsJSONRequestBody defines body for CreateProjectSettings for application/json ContentType.
type CreateProjectSettingsJSONRequestBody CreateProjectSettingsJSONBody

// UpdateProjectSettingsJSONRequestBody defines body for UpdateProjectSettings for application/json ContentType.
type UpdateProjectSettingsJSONRequestBody UpdateProjectSettingsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List info of all projects set up for Experimentation
	// (GET /projects)
	ListProjects(w http.ResponseWriter, r *http.Request)
	// Get all parameters required for generating treatments for the given project
	// (GET /projects/{project_id}/experiment-variables)
	GetProjectExperimentVariables(w http.ResponseWriter, r *http.Request, projectId int64)
	// Get experiments for a project w.r.t. query params
	// (GET /projects/{project_id}/experiments)
	ListExperiments(w http.ResponseWriter, r *http.Request, projectId int64, params ListExperimentsParams)
	// Create a new experiment for a project
	// (POST /projects/{project_id}/experiments)
	CreateExperiment(w http.ResponseWriter, r *http.Request, projectId int64)
	// Get details of an experiment with the given experiment_id and project_id
	// (GET /projects/{project_id}/experiments/{experiment_id})
	GetExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64)
	// Update an experiment with the given experiment_id and project_id
	// (PUT /projects/{project_id}/experiments/{experiment_id})
	UpdateExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64)
	// Disable an experiment with the given experiment_id and project_id
	// (PUT /projects/{project_id}/experiments/{experiment_id}/disable)
	DisableExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64)
	// Enable an experiment with the given experiment_id and project_id
	// (PUT /projects/{project_id}/experiments/{experiment_id}/enable)
	EnableExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64)
	// List an experiment's historical versions
	// (GET /projects/{project_id}/experiments/{experiment_id}/history)
	ListExperimentHistory(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64, params ListExperimentHistoryParams)
	// List an experiment's historical versions
	// (GET /projects/{project_id}/experiments/{experiment_id}/history/{version})
	GetExperimentHistory(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64, version int64)
	// Get all segmenter configurations required for generating experiments for the given project
	// (GET /projects/{project_id}/segmenters)
	ListSegmenters(w http.ResponseWriter, r *http.Request, projectId int64, params ListSegmentersParams)
	// Create a new project-specific segmenter
	// (POST /projects/{project_id}/segmenters)
	CreateSegmenter(w http.ResponseWriter, r *http.Request, projectId int64)
	// Delete a project-specific segmenter
	// (DELETE /projects/{project_id}/segmenters/{name})
	DeleteSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string)
	// Get the global/project-specific segmenter by name
	// (GET /projects/{project_id}/segmenters/{name})
	GetSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string)
	// Update an existing project-specific segmenter
	// (PUT /projects/{project_id}/segmenters/{name})
	UpdateSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string)
	// Get the settings for the given project
	// (GET /projects/{project_id}/settings)
	GetProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64)
	// Set up new project for Experimentation
	// (POST /projects/{project_id}/settings)
	CreateProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64)
	// Update the settings for the given project
	// (PUT /projects/{project_id}/settings)
	UpdateProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List info of all projects set up for Experimentation
// (GET /projects)
func (_ Unimplemented) ListProjects(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all parameters required for generating treatments for the given project
// (GET /projects/{project_id}/experiment-variables)
func (_ Unimplemented) GetProjectExperimentVariables(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get experiments for a project w.r.t. query params
// (GET /projects/{project_id}/experiments)
func (_ Unimplemented) ListExperiments(w http.ResponseWriter, r *http.Request, projectId int64, params ListExperimentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new experiment for a project
// (POST /projects/{project_id}/experiments)
func (_ Unimplemented) CreateExperiment(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get details of an experiment with the given experiment_id and project_id
// (GET /projects/{project_id}/experiments/{experiment_id})
func (_ Unimplemented) GetExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update an experiment with the given experiment_id and project_id
// (PUT /projects/{project_id}/experiments/{experiment_id})
func (_ Unimplemented) UpdateExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Disable an experiment with the given experiment_id and project_id
// (PUT /projects/{project_id}/experiments/{experiment_id}/disable)
func (_ Unimplemented) DisableExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Enable an experiment with the given experiment_id and project_id
// (PUT /projects/{project_id}/experiments/{experiment_id}/enable)
func (_ Unimplemented) EnableExperiment(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List an experiment's historical versions
// (GET /projects/{project_id}/experiments/{experiment_id}/history)
func (_ Unimplemented) ListExperimentHistory(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64, params ListExperimentHistoryParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List an experiment's historical versions
// (GET /projects/{project_id}/experiments/{experiment_id}/history/{version})
func (_ Unimplemented) GetExperimentHistory(w http.ResponseWriter, r *http.Request, projectId int64, experimentId int64, version int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all segmenter configurations required for generating experiments for the given project
// (GET /projects/{project_id}/segmenters)
func (_ Unimplemented) ListSegmenters(w http.ResponseWriter, r *http.Request, projectId int64, params ListSegmentersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new project-specific segmenter
// (POST /projects/{project_id}/segmenters)
func (_ Unimplemented) CreateSegmenter(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a project-specific segmenter
// (DELETE /projects/{project_id}/segmenters/{name})
func (_ Unimplemented) DeleteSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the global/project-specific segmenter by name
// (GET /projects/{project_id}/segmenters/{name})
func (_ Unimplemented) GetSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update an existing project-specific segmenter
// (PUT /projects/{project_id}/segmenters/{name})
func (_ Unimplemented) UpdateSegmenter(w http.ResponseWriter, r *http.Request, projectId int64, name string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the settings for the given project
// (GET /projects/{project_id}/settings)
func (_ Unimplemented) GetProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Set up new project for Experimentation
// (POST /projects/{project_id}/settings)
func (_ Unimplemented) CreateProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update the settings for the given project
// (PUT /projects/{project_id}/settings)
func (_ Unimplemented) UpdateProjectSettings(w http.ResponseWriter, r *http.Request, projectId int64) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListProjects operation middleware
func (siw *ServerInterfaceWrapper) ListProjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjects(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProjectExperimentVariables operation middleware
func (siw *ServerInterfaceWrapper) GetProjectExperimentVariables(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProjectExperimentVariables(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListExperiments operation middleware
func (siw *ServerInterfaceWrapper) ListExperiments(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListExperimentsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "status_friendly" -------------

	err = runtime.BindQueryParameter("form", true, false, "status_friendly", r.URL.Query(), &params.StatusFriendly)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status_friendly", Err: err})
		return
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_time", Err: err})
		return
	}

	// ------------- Optional query parameter "tier" -------------

	err = runtime.BindQueryParameter("form", true, false, "tier", r.URL.Query(), &params.Tier)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tier", Err: err})
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "updated_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_by", r.URL.Query(), &params.UpdatedBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "updated_by", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_time", Err: err})
		return
	}

	// ------------- Optional query parameter "segment" -------------

	err = runtime.BindQueryParameter("form", true, false, "segment", r.URL.Query(), &params.Segment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "segment", Err: err})
		return
	}

	// ------------- Optional query parameter "include_weak_match" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_weak_match", r.URL.Query(), &params.IncludeWeakMatch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_weak_match", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListExperiments(w, r, projectId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateExperiment operation middleware
func (siw *ServerInterfaceWrapper) CreateExperiment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateExperiment(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetExperiment operation middleware
func (siw *ServerInterfaceWrapper) GetExperiment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExperiment(w, r, projectId, experimentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateExperiment operation middleware
func (siw *ServerInterfaceWrapper) UpdateExperiment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateExperiment(w, r, projectId, experimentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DisableExperiment operation middleware
func (siw *ServerInterfaceWrapper) DisableExperiment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DisableExperiment(w, r, projectId, experimentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// EnableExperiment operation middleware
func (siw *ServerInterfaceWrapper) EnableExperiment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnableExperiment(w, r, projectId, experimentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListExperimentHistory operation middleware
func (siw *ServerInterfaceWrapper) ListExperimentHistory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListExperimentHistoryParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListExperimentHistory(w, r, projectId, experimentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetExperimentHistory operation middleware
func (siw *ServerInterfaceWrapper) GetExperimentHistory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "experiment_id" -------------
	var experimentId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "experiment_id", runtime.ParamLocationPath, chi.URLParam(r, "experiment_id"), &experimentId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "experiment_id", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetExperimentHistory(w, r, projectId, experimentId, version)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSegmenters operation middleware
func (siw *ServerInterfaceWrapper) ListSegmenters(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSegmentersParams

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", r.URL.Query(), &params.Scope)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scope", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSegmenters(w, r, projectId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateSegmenter operation middleware
func (siw *ServerInterfaceWrapper) CreateSegmenter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSegmenter(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSegmenter operation middleware
func (siw *ServerInterfaceWrapper) DeleteSegmenter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSegmenter(w, r, projectId, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSegmenter operation middleware
func (siw *ServerInterfaceWrapper) GetSegmenter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSegmenter(w, r, projectId, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateSegmenter operation middleware
func (siw *ServerInterfaceWrapper) UpdateSegmenter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSegmenter(w, r, projectId, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProjectSettings operation middleware
func (siw *ServerInterfaceWrapper) GetProjectSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProjectSettings(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateProjectSettings operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectSettings(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateProjectSettings operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectId int64

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, chi.URLParam(r, "project_id"), &projectId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectSettings(w, r, projectId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects", wrapper.ListProjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/experiment-variables", wrapper.GetProjectExperimentVariables)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/experiments", wrapper.ListExperiments)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/experiments", wrapper.CreateExperiment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}", wrapper.GetExperiment)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}", wrapper.UpdateExperiment)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}/disable", wrapper.DisableExperiment)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}/enable", wrapper.EnableExperiment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}/history", wrapper.ListExperimentHistory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/experiments/{experiment_id}/history/{version}", wrapper.GetExperimentHistory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/segmenters", wrapper.ListSegmenters)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/segmenters", wrapper.CreateSegmenter)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/segmenters/{name}", wrapper.DeleteSegmenter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/segmenters/{name}", wrapper.GetSegmenter)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/segmenters/{name}", wrapper.UpdateSegmenter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/settings", wrapper.GetProjectSettings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/settings", wrapper.CreateProjectSettings)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/settings", wrapper.UpdateProjectSettings)
	})

	return r
}
